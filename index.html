<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grocery Scanner - Expiry Date Tracker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 500px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #333;
      font-size: 2rem;
      margin-bottom: 10px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .header p {
      color: #666;
      font-size: 1rem;
    }

    .config-section {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 25px;
      border: 2px solid #e9ecef;
    }

    .config-section h3 {
      color: #333;
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .input-group {
      margin-bottom: 15px;
    }

    .input-group label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 500;
    }

    .input-group input {
      width: 100%;
      padding: 12px;
      border: 2px solid #e1e5e9;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s ease;
    }

    .input-group input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .camera-section {
      text-align: center;
      margin: 25px 0;
    }

    #video {
      width: 100%;
      max-width: 400px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .btn {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 25px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 10px;
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .status {
      text-align: center;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      font-weight: 500;
    }

    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }

    .results {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
      border: 2px solid #e9ecef;
    }

    .results h3 {
      color: #333;
      margin-bottom: 15px;
    }

    .result-item {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      border-left: 4px solid #667eea;
    }

    .result-item strong {
      color: #333;
    }

    canvas {
      display: none;
    }

    .loading {
      display: none;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .loading.show {
      display: flex;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üõí Grocery Scanner</h1>
      <p>Scan products to track expiry dates</p>
    </div>

    <div class="config-section">
      <h3>üîß Configuration</h3>
      <div class="input-group">
        <label for="tableName">Table Name:</label>
        <input type="text" id="tableName" placeholder="Groceries" value="Groceries">
      </div>
      <div class="input-group">
        <label for="processingMode">Processing Mode:</label>
        <select id="processingMode"
          style="width: 100%; padding: 12px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 16px;">
          <option value="ai">ü§ñ AI Processing (Recommended)</option>
          <option value="ocr">üîç OCR Only</option>
          <option value="both">üöÄ AI + OCR Fallback</option>
        </select>
      </div>
      <div class="input-group">
        <label for="openaiKey">OpenAI API Key (for AI processing):</label>
        <input type="password" id="openaiKey" placeholder="sk-...">
        <small style="color: #666; font-size: 0.85rem;">Required for AI processing. Get one from
          platform.openai.com</small>
      </div>
      <div style="font-size: 0.9rem; color: #666; margin-top: 10px;">
        ‚úÖ Airtable credentials configured
      </div>
    </div>

    <div class="camera-section">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="canvas"></canvas>
      <br>
      <button class="btn" id="startCamera">üì∑ Start Camera</button>
      <button class="btn" id="captureBtn" disabled>üì∏ Capture & Scan</button>
    </div>

    <div class="loading" id="loading">
      <div class="spinner"></div>
      <span style="margin-left: 10px;">Processing image...</span>
    </div>

    <div id="status"></div>

    <div id="results"></div>
  </div>

  <script>
    let video, canvas, ctx;
    let stream = null;

    // Initialize elements
    document.addEventListener('DOMContentLoaded', function () {
      video = document.getElementById('video');
      canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      setupEventListeners();
    });

    function setupEventListeners() {
      document.getElementById('startCamera').addEventListener('click', startCamera);
      document.getElementById('captureBtn').addEventListener('click', captureAndScan);
    }

    async function startCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });

        video.srcObject = stream;
        document.getElementById('captureBtn').disabled = false;
        document.getElementById('startCamera').textContent = '‚úÖ Camera Active';
        showStatus('Camera started successfully!', 'success');
      } catch (err) {
        showStatus('Error accessing camera: ' + err.message, 'error');
      }
    }

    async function captureAndScan() {
      if (!validateConfig()) return;

      // Set canvas size to match video
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      // Draw current video frame to canvas
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Convert to blob for processing
      canvas.toBlob(async (blob) => {
        const processingMode = document.getElementById('processingMode').value;

        if (processingMode === 'ai') {
          await performAIAnalysis(blob);
        } else if (processingMode === 'ocr') {
          await performOCR(blob);
        } else if (processingMode === 'both') {
          await performAIWithOCRFallback(blob);
        }
      }, 'image/jpeg', 0.8);
    }

    async function performAIAnalysis(imageBlob) {
      const loadingEl = document.getElementById('loading');
      loadingEl.classList.add('show');

      try {
        const anthropicKey = document.getElementById('openaiKey').value;
        if (!anthropicKey) throw new Error('Anthropic API key is required for AI processing');

        showStatus('ü§ñ Claude analyzing image for product information...', 'info');

        // Convert image to base64 (just the base64 part)
        const base64Image = (await blobToBase64(imageBlob)).split(',')[1];

        const response = await fetch("https://api.anthropic.com/v1/messages", {
          method: "POST",
          headers: {
            "x-api-key": anthropicKey,
            "anthropic-version": "2023-06-01",
            "content-type": "application/json"
          },
          body: JSON.stringify({
            model: "claude-3-opus-20240229",
            max_tokens: 1024,
            messages: [
              {
                role: "user",
                content: [
                  {
                    type: "text",
                    text: `Analyze this grocery product image and extract the following info in JSON:
{
  "productName": "...",
  "brand": "...",
  "expiryDate": "DD/MM/YYYY",
  "category": "...",
  "barcode": "...",
  "confidence": "high/medium/low"
}`
                  },
                  {
                    type: "image",
                    source: {
                      type: "base64",
                      media_type: "image/jpeg",
                      data: base64Image
                    }
                  }
                ]
              }
            ]
          })
        });

        loadingEl.classList.remove('show');

        if (!response.ok) throw new Error(`Claude API error: ${response.statusText}`);

        const result = await response.json();
        const claudeText = result?.content?.[0]?.text || '';

        let extractedData;
        try {
          extractedData = JSON.parse(claudeText);
        } catch {
          extractedData = parseAITextResponse(claudeText);
        }

        const processedData = {
          productName: extractedData.productName || 'Unknown Product',
          brand: extractedData.brand || '',
          expiryDate: extractedData.expiryDate || '',
          category: extractedData.category || '',
          barcode: extractedData.barcode || '',
          confidence: extractedData.confidence || 'medium',
          processingMethod: 'Claude AI'
        };

        displayResults(processedData);

        if (processedData.expiryDate || processedData.productName !== 'Unknown Product') {
          await saveToAirtable(processedData);
        } else {
          showStatus('‚ö†Ô∏è Claude could not extract enough product information.', 'error');
        }

      } catch (error) {
        loadingEl.classList.remove('show');
        showStatus('Claude Analysis Error: ' + error.message, 'error');
      }
    }

    async function performAIWithOCRFallback(imageBlob) {
      try {
        showStatus('üöÄ Trying AI analysis first...', 'info');
        await performAIAnalysis(imageBlob);
      } catch (error) {
        showStatus('AI failed, falling back to OCR...', 'info');
        await performOCR(imageBlob);
      }
    }

    function parseAITextResponse(text) {
      // Fallback parser if JSON parsing fails
      const data = {
        productName: '',
        expiryDate: '',
        brand: '',
        category: '',
        confidence: 'low'
      };

      const lines = text.split('\n');
      for (let line of lines) {
        const lower = line.toLowerCase();
        if (lower.includes('product') && lower.includes('name')) {
          data.productName = line.split(':')[1]?.trim().replace(/"/g, '') || '';
        } else if (lower.includes('expiry') || lower.includes('date')) {
          data.expiryDate = line.split(':')[1]?.trim().replace(/"/g, '') || '';
        } else if (lower.includes('brand')) {
          data.brand = line.split(':')[1]?.trim().replace(/"/g, '') || '';
        }
      }

      return data;
    }

    async function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    async function performOCR(imageBlob) {
      const loadingEl = document.getElementById('loading');
      loadingEl.classList.add('show');

      try {
        showStatus('üîç Analyzing image with OCR...', 'info');

        const { data: { text } } = await Tesseract.recognize(imageBlob, 'eng', {
          logger: m => {
            if (m.status === 'recognizing text') {
              showStatus(`Processing... ${Math.round(m.progress * 100)}%`, 'info');
            }
          }
        });

        loadingEl.classList.remove('show');

        if (text.trim()) {
          const extractedData = extractProductInfo(text);
          extractedData.processingMethod = 'OCR';
          displayResults(extractedData);

          if (extractedData.expiryDate || extractedData.productName) {
            await saveToAirtable(extractedData);
          }
        } else {
          showStatus('No text detected in image. Try again with better lighting.', 'error');
        }

      } catch (error) {
        loadingEl.classList.remove('show');
        showStatus('OCR Error: ' + error.message, 'error');
      }
    }

    function extractProductInfo(text) {
      const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);

      let productName = '';
      let expiryDate = '';
      let bestBefore = '';
      let useBy = '';

      // Common date patterns
      const datePatterns = [
        /(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/g,
        /(\d{2,4})[\/\-.](\d{1,2})[\/\-.](\d{1,2})/g,
        /(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{2,4})/gi,
        /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{1,2}),?\s+(\d{2,4})/gi
      ];

      // Look for expiry-related keywords
      const expiryKeywords = ['exp', 'expiry', 'expires', 'best before', 'use by', 'sell by', 'bb', 'ub'];

      for (let line of lines) {
        const lowerLine = line.toLowerCase();

        // Check if line contains expiry keywords
        for (let keyword of expiryKeywords) {
          if (lowerLine.includes(keyword)) {
            // Extract date from this line
            for (let pattern of datePatterns) {
              const match = line.match(pattern);
              if (match) {
                if (lowerLine.includes('best before') || lowerLine.includes('bb')) {
                  bestBefore = match[0];
                } else if (lowerLine.includes('use by') || lowerLine.includes('ub')) {
                  useBy = match[0];
                } else {
                  expiryDate = match[0];
                }
              }
            }
          }
        }

        // If no expiry date found yet, look for standalone dates
        if (!expiryDate && !bestBefore && !useBy) {
          for (let pattern of datePatterns) {
            const match = line.match(pattern);
            if (match) {
              expiryDate = match[0];
              break;
            }
          }
        }

        // Try to identify product name (usually one of the first few lines with decent length)
        if (!productName && line.length > 3 && line.length < 50 &&
          !lowerLine.includes('exp') && !lowerLine.includes('best') &&
          !/^\d+[\/\-.\s]/.test(line)) {
          productName = line;
        }
      }

      return {
        productName: productName || 'Unknown Product',
        expiryDate: expiryDate || bestBefore || useBy || '',
        allText: text,
        detectedLines: lines
      };
    }

    function displayResults(data) {
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = `
                  <h3>üìã Scan Results</h3>
                  <div class="result-item">
                      <strong>Processing Method:</strong> ${data.processingMethod || 'OCR'}
                      ${data.confidence ? `<span style="margin-left: 10px; color: ${data.confidence === 'high' ? '#28a745' : data.confidence === 'medium' ? '#ffc107' : '#dc3545'};">
                          ${data.confidence.toUpperCase()} CONFIDENCE
                      </span>` : ''}
                  </div>
                  <div class="result-item">
                      <strong>Product:</strong> ${data.productName || 'Not detected'}
                  </div>
                  ${data.brand ? `<div class="result-item"><strong>Brand:</strong> ${data.brand}</div>` : ''}
                  <div class="result-item">
                      <strong>Expiry Date:</strong> ${data.expiryDate || 'Not detected'}
                  </div>
                  ${data.category ? `<div class="result-item"><strong>Category:</strong> ${data.category}</div>` : ''}
                  ${data.barcode ? `<div class="result-item"><strong>Barcode:</strong> ${data.barcode}</div>` : ''}
                  ${data.allText ? `<div class="result-item">
                      <strong>All Detected Text:</strong><br>
                      <small style="color: #666;">${data.allText.substring(0, 200)}${data.allText.length > 200 ? '...' : ''}</small>
                  </div>` : ''}
              `;
    }

    async function saveToAirtable(data) {
      // Hardcoded credentials - Replace with your actual values
      const token = 'pat37xdtUv9ZoeR21.223e5f20177f497b21d56b71d050eba62ebc3cc4a68a09646da91a25432b6cfd';
      const baseId = 'appHn3cLbE1rwuBVX';
      const tableName = document.getElementById('tableName').value;

      if (!data.expiryDate && !data.productName) {
        showStatus('No product name or expiry date detected to save', 'error');
        return;
      }

      try {
        const url = `https://api.airtable.com/v0/${baseId}/${encodeURIComponent(tableName)}`;

        const record = {
          fields: {
            'Product Name': data.productName || 'Unknown Product',
            'Scanned Date': new Date().toISOString().split('T')[0],
            'Processing Method': data.processingMethod || 'OCR'
          }
        };

        if (data.expiryDate) {
          record.fields['Expiry Date'] = data.expiryDate;
        }

        if (data.brand) {
          record.fields['Brand'] = data.brand;
        }

        if (data.category) {
          record.fields['Category'] = data.category;
        }

        if (data.barcode) {
          record.fields['Barcode'] = data.barcode;
        }

        if (data.confidence) {
          record.fields['Confidence'] = data.confidence;
        }

        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(record)
        });

        if (response.ok) {
          const result = await response.json();
          showStatus('‚úÖ Successfully saved to Airtable!', 'success');
        } else {
          const error = await response.text();
          showStatus('Failed to save to Airtable: ' + error, 'error');
        }

      } catch (error) {
        showStatus('Error saving to Airtable: ' + error.message, 'error');
      }
    }

    function validateConfig() {
      const tableName = document.getElementById('tableName').value;
      const processingMode = document.getElementById('processingMode').value;
      const openaiKey = document.getElementById('openaiKey').value;

      if (!tableName) {
        showStatus('Please enter a table name', 'error');
        return false;
      }

      if ((processingMode === 'ai' || processingMode === 'both') && !openaiKey) {
        showStatus('OpenAI API key is required for AI processing mode', 'error');
        return false;
      }

      return true;
    }

    function showStatus(message, type) {
      const statusDiv = document.getElementById('status');
      statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', function () {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>

</html>